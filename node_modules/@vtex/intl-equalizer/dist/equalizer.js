'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.equalize = equalize;
exports.equalizeRegionLocales = equalizeRegionLocales;

var _diff = require('diff');

var _constants = require('./constants');

var _fileReader = require('./fileReader');

var _fileReader2 = _interopRequireDefault(_fileReader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getExtraKeys(referenceKeys, currentLanguageKeys) {
  return currentLanguageKeys.filter(key => !referenceKeys.some(currKey => currKey === key));
}

function getCorrectLines(referenceOrder, languageOrder) {
  const diff = (0, _diff.diffArrays)(referenceOrder, languageOrder);

  const correctLines = diff.reduce((chunks, line) => {
    const key = line.value[0];
    if (line.removed || line.added) {
      if (!chunks[key]) {
        chunks[key] = {};
      }
    }

    if (line.removed) {
      chunks[key] = _extends({}, chunks[key], {
        wrongLine: languageOrder.indexOf(key)
      });
    } else if (line.added) {
      chunks[key] = _extends({}, chunks[key], {
        correctLine: referenceOrder.indexOf(key)
      });
    }

    return chunks;
  }, {});

  return Object.keys(correctLines).map(key => {
    return _extends({
      key
    }, correctLines[key]);
  });
}

function equalize({ languages, localesDirectory, referenceLocale }) {
  const termsPerLanguage = (0, _fileReader2.default)({ languages, localesDirectory });

  const hasEmptyLanguage = languages.some(language => !termsPerLanguage[language] || Object.keys(termsPerLanguage[language]).length === 0);

  if (hasEmptyLanguage) {
    return {
      error: {
        code: _constants.ERRORS.ERROR_NO_KEYS_LOCALE,
        data: languages.find(language => !termsPerLanguage[language] || Object.keys(termsPerLanguage[language]).length === 0)
      }
    };
  }

  const processedLanguages = {};

  Object.keys(termsPerLanguage[referenceLocale]).forEach(key => {
    const referenceOrder = Object.keys(termsPerLanguage[referenceLocale]);

    languages.forEach(language => {
      if (!processedLanguages[language]) {
        processedLanguages[language] = {
          missingKeys: [],
          wrongOrderKeys: []
        };
      }

      if (!termsPerLanguage[language][key]) {
        processedLanguages[language].missingKeys.push(_extends({
          key
        }, termsPerLanguage[referenceLocale][key]));
      }

      const languageOrder = Object.keys(termsPerLanguage[language]);

      processedLanguages[language].wrongOrderKeys = getCorrectLines(referenceOrder, languageOrder);

      processedLanguages[language].extraKeys = getExtraKeys(Object.keys(termsPerLanguage[referenceLocale]), Object.keys(termsPerLanguage[language]));
    });
  });

  return processedLanguages;
}

function equalizeRegionLocales({
  regionLocales,
  referenceLocale,
  localesDirectory
}) {
  const languages = [...regionLocales, referenceLocale];
  const termsPerLanguage = (0, _fileReader2.default)({ languages, localesDirectory });

  const processedLanguages = {};

  regionLocales.forEach(region => {
    processedLanguages[region] = {
      extraKeys: getExtraKeys(Object.keys(termsPerLanguage[referenceLocale]), Object.keys(termsPerLanguage[region]))
    };
  });

  return processedLanguages;
}